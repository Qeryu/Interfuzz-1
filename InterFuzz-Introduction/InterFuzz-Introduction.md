本文介绍的研究已获 ICSE 2026 第二轮接收。

# InterFuzz：基于异构程序图的 Java 优化编译器模糊测试方法

Java 是一种被广泛采用的编程语言，以其“跨平台兼容性”著称。这种特性来源于 Java 程序会被编译成 **字节码（bytecode）**，由 **Java 虚拟机（JVM）** 来执行。
 为了提升运行效率和性能，现代 JVM 通常集成了多种**优化编译器**，包括 **即时编译器（Just-In-Time，JIT）** 和 **提前编译器（Ahead-Of-Time，AOT）**。
 这些优化编译器在保持程序语义不变的前提下，对代码进行转换与优化。

以 JIT 编译器为例，OpenJDK 中的 **HotSpot** 编译器会在程序运行过程中，动态地对“热点代码”进行优化。而 AOT 编译器（如 Android 生态系统中的 **R8**）则在构建阶段执行静态分析和优化，从而减少应用体积、混淆代码并增强安全性。此外，**Android Runtime（ART）** 采用了一种混合策略：在安装时使用 AOT 编译，在运行时结合 JIT 优化，以平衡应用启动速度和运行时性能。

## 类间结构与编译优化的关系

面向对象编程（Object-Oriented Programming, OOP）通过“对象”来封装状态与行为。在 Java 中，对象由 **类（Class）** 定义，而类不仅描述了单个对象的属性与方法，还通过多种机制来组织和协调对象之间的交互——本文称之为 **类间结构（inter-class structures）**。常见的类间结构包括：**继承（inheritance）**、**接口实现（interface implementation）** 以及 **嵌套类（nested class）** 等。这些机制是构建模块化、可扩展、可维护软件系统的关键，它们实现了代码复用、抽象和多态等核心特性。

![](./5-inter-class-structures.png)

然而，这些复杂的类间关系在编译优化过程中也带来了挑战。Java 优化编译器需要准确分析这些关系，以便在不改变语义的前提下执行优化。若分析错误，就可能导致错误的优化，进而引发逻辑错误甚至系统崩溃。

为更直观地展示复杂类间结构对 Java 编译器优化过程的影响，我们以 **HotSpot JIT 编译器** 中的一个真实优化错误为例（见下图）。在该示例中，程序包含两个类 `C1` 与 `C2`，它们之间通过静态字段和初始化块发生交互。`C1` 在构造函数中创建 `C2` 的实例（第 3 行），而 `C2` 的静态初始化块（第 6 行）会在构造过程中修改 `C1` 的静态字段 `str`。然而，HotSpot 的 JIT 优化器在分析这一跨类访问顺序时出错——它错误地假设 `str` 在构造函数执行时仍为 `null`，从而生成了语义错误的优化代码，导致程序运行结果与预期不符。

![image-20251026141934462](./motivating-example.png)

该示例揭示出一个关键问题：**编译器在处理跨类的依赖关系和执行顺序时，若分析模型不足以捕捉复杂的类间交互，就极易引发错误优化**。通过我们对历史缺陷的统计分析发现，在 R8 编译器的缺陷案例中，有 **76.4% 的错误** 仅能在具有复杂类间结构的测试程序中被触发。这一观察表明：**验证 Java 优化编译器在复杂类间结构下的正确性，不仅重要，而且迫切。**

## 现有模糊测试方法的局限

当前的 Java 编译器模糊测试主要分为两类：

- **生成式（generation-based）** 方法
- **变异式（mutation-based）** 方法

但这两类方法大多聚焦于**类内（intra-class）**或**方法内（intra-method）**的结构，难以生成拥有复杂类间关系的多类程序。例如，JITFuzz (ICSE'23) 和 MopFuzzer (ASPLOS'24) 等工具主要测试单类结构或特定的 JVM 优化场景；Jetris (CCS'24) 等工具甚至只针对单个方法片段进行模糊测试。因此，这些工具难以探索跨类交互所引发的优化错误。换言之，**当前模糊测试无法系统性地生成具有复杂类间结构的测试样例**，这成为揭露编译器优化错误的主要瓶颈。

## 生成复杂类间结构的挑战

生成具有复杂类间结构的 Java 程序是一项极具挑战性的任务：

1. **结构建模困难**：
    类之间的关系多种多样，涉及实例化、方法调用、字段访问等多种语法形式。 现有方法往往只能捕捉局部类内逻辑，无法全面描述类之间的复杂依赖。
2. **程序生成复杂**：
    在构造和修改这些结构时，需要同时满足语法与语义约束。 稍有不慎就可能生成无效或不可编译的测试程序。
3. **搜索空间爆炸**：
    引入类间结构后，程序的语法组合会急剧增多。 即便是细微的代码修改，也可能显著改变程序语义，导致模糊测试效率急剧下降。

## 我们的方法：InterFuzz

为了解决复杂类间结构建模困难、程序生成约束复杂、以及搜索空间爆炸等三大挑战，本文提出了一种新型 Java 编译器模糊测试框架——**InterFuzz**。InterFuzz 通过引入 **异构程序图（Heterogeneous Program Graph, HPG）** 作为核心抽象，并结合 **跨类结构变异算子（Inter-Class Mutators）** 与 **图复杂度引导（Graph Complexity Guidance）** 三个关键组件，实现了系统化的复杂类间结构生成与优化编译器验证。下文将详细介绍这三个核心设计。

![](./overview.png)

### 1. **异构程序图（Heterogeneous Program Graph, HPG）**
为了统一表示 Java 程序中多样的类间结构（如继承、接口实现、嵌套、泛型约束与引用等），我们提出了**异构程序图（Heterogeneous Program Graph, HPG）**。该模型将程序抽象为一个多类型有向图，使复杂的类间依赖关系能够以结构化形式进行分析与操作。通过这种表示，我们可以将抽象的“结构复杂性”问题转化为可量化的图结构问题，为后续的模糊测试引导提供基础。

形式上，程序 $\mathcal{P}$ 的异构程序图定义为：
\[
HPG(\mathcal{P}) = (V_\mathcal{P}, \mathcal{T}, E_\mathcal{P}, \mathcal{E})
\]
其中，$V_\mathcal{P}$ 为节点集合，表示程序中的类间实体（inter-class entities）；$E_\mathcal{P}$ 为有向边集合，表示实体间的类间结构（inter-class structures）；$\mathcal{T}$ 与 $\mathcal{E}$ 分别为节点类型集合与边类型集合。  节点类型全集定义为：
\[
\mathcal{T} = \{Class, Intf, Mtd, Fld\}
\]
其中 `Class` 表示类，`Intf` 表示接口，`Mtd` 表示方法，`Fld` 表示字段。每个节点 $v=(t,n)$，其中 $t \in \mathcal{T}$ 表示实体类型，$n$ 为实体属性（如名称或修饰符）。 边类型全集定义为：
\[
\mathcal{E} = \{
\textit{Inheritance},
\textit{Interface Implementation},
\textit{Nesting},
\textit{Generic Bounds},
\textit{Reference}
\}
\]
其中，`Inheritance` 表示继承关系，`Interface Implementation` 表示接口实现，`Nesting` 表示类嵌套，`Generic Bounds` 表示泛型上界约束，而 `Reference` 表示对象实例化、方法调用或字段访问。每条边 $e=(v_s,v_t,r,n)$ 由源节点 $v_s$、目标节点 $v_t$、边类型 $r \in \mathcal{E}$ 及属性 $n$ 组成，用于描述类间依赖的语义特征。

下图展示了示例的 HPG 表示，其中从 `C0.main` 到 `C1` 与 `C2` 的 `Reference` 边表示对象创建，而 `I2 → I1` 的 `Inheritance` 边表示接口继承。HPG 将这些结构统一为可分析的图形式，为后续的结构变异与复杂度引导提供了基础。

![](./motivating-example-with-hpg.png)

### 2. **跨类结构变异算子（Inter-Class Mutators）**

为了生成包含复杂类间结构的测试程序，InterFuzz 设计了一组 **跨类结构变异算子（Inter-Class Mutators）**。基于异构程序图（HPG），这些算子通过在图上操作节点和边来修改程序结构，从而将代码级的复杂修改转化为可控的图操作。

变异算子的设计遵循**模块化原则**：每个算子只执行一个原子操作，避免相互干扰，并可通过组合实现更复杂的类间关系。算子分为两类：
- **节点添加（Node Addition）**：在图中新增程序实体，如“Add Class Node”生成一个新的类；
- **边添加（Edge Addition）**：在现有节点间建立关系，如“Add Inheritance Edge”表示类间继承。

InterFuzz 共针对 HPG 中的五类结构（继承、接口实现、嵌套、泛型约束、引用）和四类实体（类、接口、方法、字段）设计了对应算子。例如：

- **Add Inheritance Edge**：在两个类节点间添加继承关系；
- **Add Nesting Edge**：将一个类嵌入另一个类；
- **Add Class Node**：新增类节点，供后续结构扩展使用。

下图展示了三个代表性算子的操作示意。通过在图层面进行精细控制，InterFuzz 能系统地生成具有多样类间关系的测试用例。

![image-20251026150510146](./inter-class-mutators)

### 3. **图复杂度引导（Graph Complexity Guidance）**

为在变异过程中优先生成“更可能触发优化缺陷”的测试样例，InterFuzz 引入**图复杂度引导（Graph Complexity Guidance）**。直觉很简单：**越复杂的类间结构，越容易覆盖到编译器更深层的优化路径与边界条件**。这里的“复杂”包含两层含义：

- **种类的复杂（关系多样性）**：同一实体若同时参与多种类间关系（如继承、接口实现、嵌套、泛型约束、引用），编译器需要在多种分析假设下综合处理，更容易暴露优化中的不一致与冲突。多样性越高，潜在行为分支越多，触发缺陷的机会越大。

- **数量的复杂（关系规模）**：实体连接的关系越多（被更多方法调用、持有/访问更多字段、与更多类型建立层级关系），其在程序中的“交汇度”越高，小的修改就可能在更广的范围内产生连锁效应，放大编译器优化假设的偏差。

基于上述原则，InterFuzz 在每次应用变异算子后，评估图中各实体**参与关系的种类**与**数量**是否得到提升：  
- 若某次变异同时提升了多样性与规模（比如为同一类新增一种不同类型的跨类关系，并引入新的连接），该变异将被“奖励”，未来被选择的概率更高；  
- 若只带来机械性的膨胀（仅重复同一关系类型，缺乏新语义连接），则不被偏好，避免无效增大。

这种基于“**先多样、后做大；既多样，又做大**”的引导策略，使变异过程持续朝着**更丰富、更多交互、更易触发优化边界**的程序形态演化，而非单纯增加节点或边的数量。

## 实验结果与发现

我们对 InterFuzz 进行了系统评估，结果显示其在发现编译器优化缺陷方面显著优于现有方法。

- InterFuzz 成功发现了 **24 个新缺陷**，覆盖了 **HotSpot、ART 和 R8** 三个主流 Java 编译器，其中 **20 个缺陷** 已被官方确认。更重要的是，**16 个确认为“类间结构相关”的缺陷**，这些都是传统模糊测试难以触及的；
- 在 24 小时的实验中，InterFuzz 不仅发现的缺陷更多，还在代码覆盖率方面显著领先于现有工具。消融实验进一步表明，基于图复杂度的引导机制，是 InterFuzz 高效发现复杂优化错误的关键。